From beb7f389460ceb504d1c02204054578a6a459900 Mon Sep 17 00:00:00 2001
From: Garvit Varshney <gvarshney@marvell.com>
Date: Wed, 8 Oct 2025 13:39:23 -0400
Subject: [PATCH 2/2] workaround for speed multi option with prov

Signed-off-by: Garvit Varshney <gvarshney@marvell.com>
Signed-off-by: Venkata Ravichandra Mynidi <vmynidi@marvell.com>
Signed-off-by: Sriram Vatala <svatala@marvell.com>
---
 apps/speed.c | 80 ++++++++++++++++++++++++++++++++++++++++++++--------
 1 file changed, 68 insertions(+), 12 deletions(-)

diff --git a/apps/speed.c b/apps/speed.c
index 6ec6b80e48..2b66fcfe62 100644
--- a/apps/speed.c
+++ b/apps/speed.c
@@ -103,6 +103,15 @@ VirtualLock(
 # define RSA_DEFAULT_PRIME_NUM 2
 #endif

+#define MAX_PROV_OPTS 4
+struct {
+    const char *names[MAX_PROV_OPTS];
+    EVP_CIPHER **evp_cipher;
+    const char *evp_opt;
+    uint8_t mrvl_prov_en;
+    uint8_t cnt;
+} prov_opts;
+
 typedef struct openssl_speed_sec_st {
     int sym;
     int rsa;
@@ -1849,6 +1858,32 @@ static inline void cpu_pause()
        __asm__ __volatile__ ("nop");
 }
 static uint64_t *shm;
+
+int handle_defered_opts()
+{
+
+    for (int i = 0; i < prov_opts.cnt; i++) {
+        if (!app_provider_load(app_get0_libctx(), prov_opts.names[i])) {
+            BIO_printf(bio_err, "Error loading provider %s\n", prov_opts.names[i]);
+            return 1;
+        }
+    }
+    if (prov_opts.evp_opt) {
+        if (!opt_cipher_silent(prov_opts.evp_opt, prov_opts.evp_cipher)) {
+            if (have_md(prov_opts.evp_opt))
+                evp_md_name = prov_opts.evp_opt;
+        }
+        if (prov_opts.evp_cipher[0] == NULL && evp_md_name == NULL) {
+            BIO_printf(bio_err,
+                       "%s is an unknown cipher or digest\n",
+                       prov_opts.evp_opt);
+            return 1;
+        }
+    }
+
+    return 0;
+}
+
 int speed_main(int argc, char **argv)
 {
     CONF *conf = NULL;
@@ -2031,6 +2066,9 @@ int speed_main(int argc, char **argv)
                 BIO_printf(bio_err, "%s: -evp option cannot be used more than once\n", prog);
                 goto opterr;
             }
+	    prov_opts.evp_opt = opt_arg();
+	    prov_opts.evp_cipher = &evp_cipher;
+#if 0 // Defer cipher fetch till providers are loaded into app context.
             ERR_set_mark();
             if (!opt_cipher_silent(opt_arg(), &evp_cipher)) {
                 if (have_md(opt_arg()))
@@ -2044,6 +2082,7 @@ int speed_main(int argc, char **argv)
                 goto end;
             }
             ERR_pop_to_mark();
+#endif
             doit[D_EVP] = 1;
             break;
         case OPT_HMAC:
@@ -2124,8 +2163,22 @@ int speed_main(int argc, char **argv)
                 goto end;
             break;
         case OPT_PROV_CASES:
+
+	    if (o == OPT_PROV_PROVIDER) {
+		if (prov_opts.cnt < MAX_PROV_OPTS) {
+			prov_opts.names[prov_opts.cnt++] = opt_arg();
+			if ((strcmp(opt_arg(), "dpdk_provider") == 0) ||
+				(strcmp(opt_arg(), "lc_provider") == 0))
+				prov_opts.mrvl_prov_en= 1;
+		}
+	    }
+	    else if (!opt_provider(o))
+		    goto end;
+	    break;
+#if 0
             if (!opt_provider(o))
                 goto end;
+#endif
             break;
         case OPT_CONFIG:
             conf = app_load_config_modules(opt_arg());
@@ -2167,6 +2220,13 @@ int speed_main(int argc, char **argv)
         }
     }

+    if (!prov_opts.mrvl_prov_en || !multi) {
+	    if (handle_defered_opts())
+		    goto end;
+    }
+    else {
+	goto skip_provider_algo_load;
+    }
     /* find all KEMs currently available */
     kem_stack = sk_EVP_KEM_new(kems_cmp);
     EVP_KEM_do_all_provided(app_get0_libctx(), collect_kem, kem_stack);
@@ -2265,6 +2325,7 @@ int speed_main(int argc, char **argv)
     sk_EVP_SIGNATURE_pop_free(sig_stack, EVP_SIGNATURE_free);
     sig_stack = NULL;

+skip_provider_algo_load:
     /* Remaining arguments are algorithms. */
     argc = opt_num_rest();
     argv = opt_rest();
@@ -2397,18 +2458,6 @@ int speed_main(int argc, char **argv)
         }
     }

-    /* Sanity checks */
-    if (aead) {
-        if (evp_cipher == NULL) {
-            BIO_printf(bio_err, "-aead can be used only with an AEAD cipher\n");
-            goto end;
-        } else if (!(EVP_CIPHER_get_flags(evp_cipher) &
-                     EVP_CIPH_FLAG_AEAD_CIPHER)) {
-            BIO_printf(bio_err, "%s is not an AEAD cipher\n",
-                       EVP_CIPHER_get0_name(evp_cipher));
-            goto end;
-        }
-    }
     if (kems_algs_len > 0) {
         int maxcnt = get_max(kems_doit, kems_algs_len);

@@ -2553,6 +2602,13 @@ int speed_main(int argc, char **argv)
             e = NULL;
         }
     }
+
+    if (multi && prov_opts.mrvl_prov_en) {
+	if (handle_defered_opts()) {
+	    exit(1);
+	}
+    }
+
     static struct timespec start, end;
     if(multi)
     {
--
2.47.3

